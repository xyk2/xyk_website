<?xml version="1.0" encoding="UTF-8"?>
<item><pubDate>Sat, 18 May 2013 23:08:53 +0800</pubDate><title><![CDATA[Remote Weather Data Logger]]></title><url><![CDATA[remote-weather-data-logger]]></url><meta><![CDATA[remote weather logger, standalone, datalogger, avr data log, arduino data logger]]></meta><metad><![CDATA[Building a remote weather data logger meant for outdoor exposure for at least a year. Uses Elm-Chan&#039;s PetitFS for SD card access.]]></metad><menu><![CDATA[remote weather data logger]]></menu><menuOrder><![CDATA[0]]></menuOrder><menuStatus><![CDATA[]]></menuStatus><template><![CDATA[template.php]]></template><parent><![CDATA[projects]]></parent><content><![CDATA[&lt;p&gt;
	The goal is to make a remote data logger capable of continously collecting environmental data for at least a year.&lt;/p&gt;
&lt;h2&gt;
	project requirements&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;
		self sustained - no external tethered power source allowed&lt;/li&gt;
	&lt;li&gt;
		collected data will include time, sun luminance, humidity, temperature, and barometric pressure&lt;/li&gt;
	&lt;li&gt;
		24h data collection&lt;/li&gt;
	&lt;li&gt;
		data will be logged to a SD card&lt;/li&gt;
	&lt;li&gt;
		average microcontroller current should be &amp;lt;1mA&lt;/li&gt;
	&lt;li&gt;
		As many surface mount components as possible (ideally all SMT)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;
	basic circuit outline&lt;/h2&gt;
&lt;p&gt;
	Power from a bank of solar cells will be fed into a LDO linear regulator and then into a single cell lithium ion charger. A second regulator will regulate power from the lithium ion cell for the AVR, which will periodically log data into a SD card.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;
	component selection&lt;/h2&gt;
&lt;p&gt;
	Availability was the biggest factor when I chose these parts. Digikey, Mouser, and Farnell were out of the question because of the high postage rates, but luckily many parts were available locally.&lt;/p&gt;
&lt;p&gt;
	A SMPS boost/buck IC designed for energy harvesting would be ideal. Linear Technology does lots of power management stuff, so I started there. The LT3652 is close to perfect, but the input voltage range (4.95+) is too restrictive. The cells will go below that voltage when it is cloudy, and at voltages below ~10V, the efficiency of the IC drops down to 50%.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;
	revision A schematic&lt;/h2&gt;
&lt;p&gt;
	The first revision uses 1206 and 0805 SMT components.&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;a href=&quot;http://d30cz35xum7wy8.cloudfront.net/projects/remote_weather_logger/remote_weather_logger_rev_a.pdf&quot;&gt;remote_weather_logger_rev_A.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;a href=&quot;http://d30cz35xum7wy8.cloudfront.net/projects/remote_weather_logger/remote_weather_logger_rev_a_top.pdf&quot;&gt;remote_weather_logger_revA_top.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;a href=&quot;http://d30cz35xum7wy8.cloudfront.net/projects/remote_weather_logger/remote_weather_logger_rev_a_bottom.pdf&quot;&gt;remote_weather_logger_revA_bottom.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;
	SD&lt;/h2&gt;
&lt;p&gt;
	Finding and implementing a SD card library was by far the hardest part of this project. The &#039;standard&#039; library recommended by the members on avrfreaks.com is FatFS by elm-chan, which has pretty much everything you&#039;d ever need. However, the compiled code for the avr example alone is over 64 kilobytes, more than four times what I have on the mega168. I tried reducing the code size by removing functions I did not need (reading, LFNs, and directory access), but it was still way over the limit.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center; &quot;&gt;
	&lt;img alt=&quot;PetitFS compile size for the atmega328p. Compiled with winAVR &quot; src=&quot;http://d30cz35xum7wy8.cloudfront.net/projects/remote_weather_logger/petitFS_usage.png&quot; style=&quot;width: 330px; height: 72px;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
	Luckily, elm-chan has another SD library specific for low memory micros. With only read and write capability, PetitFS is a slimmed down version of FatFS that compiles down to 6600 bytes. It is also more efficient with its ram usage, which I have precious little of on the mega168.&lt;/p&gt;
&lt;p&gt;
	SD cards can be accessed with two primary protocols: the proprietary SD bus (which there are actually two versions of) and the serial peripheral interface bus. The SD bus is what all modern consumer devices use now. It allows for very high transfer speeds, but the protocol is so secret that a NDA has to be signed before the specifications can be released. The mega168 has a dedicated hardware SPI controller, and since the SPI protocol is well documented, it was a easy decision to go with SPI.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	PetitFS requires the target SD card to be formatted with the FAT system. File systems are organized into clusters and sectors. Clusters (or allocation units in windows terminology) are groups of 512-byte sectors. The very common NTFS format for computer hard drives uses 4096-byte cluster sizes, with eight sectors in each cluster. A file cannot never be smaller than the cluster size. If you try and create a .txt file with a single letter saved (one byte) on a NTFS formatted hard drive, the &#039;size-on-disk&#039; size will be one cluster, or 4096 bytes. This sounds counterintuitive, but by organizing sectors into clusters, there are a lot less memory addresses to handle.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Despite the advantages of organizing sectors into clusters, I won&#039;t be able to use it for this project. Clusters can only be appended by holding the original data in ram, adding whatever data to it, then rewriting it completely, and with a paltry 1024 bytes of ram on the mega168, the absolute largest cluster size I can use is 512 bytes (so effectively sectors and clusters are equivalent). This leaves 512 more bytes of ram for system reserves and program variables.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;
	sensors&lt;/h2&gt;
&lt;h3&gt;
	tmp102&lt;/h3&gt;
&lt;p style=&quot;text-align: center; &quot;&gt;
	&lt;img alt=&quot;Timing diagram for the TMP102 sensor. Logged with the open logic sniffer.&quot; src=&quot;http://d30cz35xum7wy8.cloudfront.net/projects/remote_weather_logger/timing_diagram_tmp102.png&quot; style=&quot;width: 100%;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
	I2C bus diagram for a slave-transmit operation on the TMP102. The first byte (0x91) contains the device address (0x48) and the read-write direction. The temperature is stored in two eight-bit registers, so two separate bytes are sent by the slave before a NACK command is issued.&amp;nbsp;&lt;/p&gt;
]]></content><private><![CDATA[]]></private><author><![CDATA[xiaoyangkao2]]></author><creation_date><![CDATA[June 16, 2012]]></creation_date><creDate>Sat, 18 May 2013 23:08:53 +0800</creDate><user><![CDATA[xiaoyangkao2]]></user></item>
